<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>European Settlement of North America</title>
<style>
  body { margin:0; overflow:hidden; }
  #container { width:100vw; height:100vh; display:block; }
  #ui {
    position:absolute;
    top:10px;
    left:50%;
    transform:translateX(-50%);
    z-index:10;
  }
  button, input { font-size:16px; margin:2px; }
</style>
</head>
<body>

<div id="ui">
  <button id="zoomIn">+</button>
  <button id="zoomOut">-</button>
  <input id="slider" type="range" min="1" max="20" step="1" value="1">
</div>
<div id="container"></div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.1.0/pako.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.147.0/examples/js/controls/OrbitControls.js"></script>

<script>
(async function(){
console.clear();

let scene, camera, renderer, controls;
let mesh, borderMesh;
const container = document.getElementById('container');

const minY = 100, maxY = 5000, zoomStep = 250;

// ---------------- Terrain cache ----------------
const terrainCache = {};       // frameNum -> { verticesArray, facesArray, colorsArray }
const CACHE_SIZE = 10;          // max frames to keep in cache

// ---------------- Load a terrain frame ----------------
async function loadTerrain(frameNum){
    // Use cache if available
    if(terrainCache[frameNum]) return terrainCache[frameNum];

    const frameStr = frameNum.toString().padStart(4,'0');
    const filename = `https://raw.githubusercontent.com/aeromidd/aeromidd.github.io/main/projects/euro-settle-america/binFiles/frame_${frameStr}.bin.gz`;
    const res = await fetch(filename);
    const compressed = await res.arrayBuffer();
    const decompressed = pako.inflate(new Uint8Array(compressed));

    const dv = new DataView(decompressed.buffer);
    let offset = 0;

    const numVertices = dv.getUint32(offset, true); offset += 4;
    const numFaces = dv.getUint32(offset, true); offset += 4;

    // Read vertices
    const vertices = new Float32Array(numVertices*3);
    for(let i=0;i<numVertices*3;i++){
        vertices[i] = dv.getFloat32(offset, true);
        offset += 4;
    }

    // Read faces
    const faces = new Uint32Array(numFaces*3);
    for(let i=0;i<numFaces*3;i++){
        faces[i] = dv.getUint32(offset, true);
        offset += 4;
    }

    // Read color indices
    const colorIndex = new Uint8Array(numVertices);
    for(let i=0;i<numVertices;i++){
        colorIndex[i] = dv.getUint8(offset);
        offset += 1;
    }

    // Reconstruct vertices
    const verticesArray = [];
    for(let i=0; i<numVertices; i++){
        const x = vertices[i];
        const y = vertices[i + numVertices];
        const z = vertices[i + 2*numVertices];
        verticesArray.push([x, z, -y]);
    }

    // Reconstruct faces
    const facesArray = [];
    for (let i = 0; i < numFaces; i++) {
        const a = faces[i];
        const b = faces[i + numFaces];
        const c = faces[i + 2*numFaces];
        facesArray.push([a, b, c]);
    }

    // Map indices to colors
    const colorMap = [
        [1,1,1],      // 0 = background
        [0,0.6,0.75], // 1 = external
        [1,0.8,0]     // 2 = internal
    ];
    const colorsArray = [];
    for(let i=0;i<numVertices;i++){
        colorsArray.push(colorMap[colorIndex[i]]);
    }

    const data = { verticesArray, facesArray, colorsArray };

    // Add to cache
    terrainCache[frameNum] = data;

    // Limit cache size
    const keys = Object.keys(terrainCache);
    if(keys.length > CACHE_SIZE){
        delete terrainCache[keys[0]];
    }

    return data;
}

// ---------------- Build Mesh ----------------
function buildMesh(verticesArray, facesArray, colorsArray){
  if(mesh){
    scene.remove(mesh);
    mesh.geometry.dispose();
    mesh.material.dispose();
  }
  if(borderMesh){
    scene.remove(borderMesh);
    borderMesh.geometry.dispose();
    borderMesh.material.dispose();
  }

  const geometry = new THREE.BufferGeometry();
  geometry.setAttribute('position', new THREE.Float32BufferAttribute(verticesArray.flat(), 3));
  geometry.setIndex(facesArray.flat());
  geometry.setAttribute('color', new THREE.Float32BufferAttribute(colorsArray.flat(), 3));
  geometry.computeVertexNormals();

  const material = new THREE.MeshStandardMaterial({
    vertexColors: true,
    side: THREE.DoubleSide,
    flatShading: true
  });

  mesh = new THREE.Mesh(geometry, material);
  scene.add(mesh);
}

// ---------------- Init ----------------
async function init(){
  scene = new THREE.Scene();

  camera = new THREE.PerspectiveCamera(50, window.innerWidth/window.innerHeight, 0.1, 5000);

  renderer = new THREE.WebGLRenderer({antialias:true});
  renderer.setClearColor(0xffffff);
  renderer.setSize(window.innerWidth, window.innerHeight);
  container.appendChild(renderer.domElement);

  // Lights
  const directional = new THREE.DirectionalLight(0xffffff, 1.21);
  directional.position.set(1000, 2000, -1000);
  scene.add(directional);
  scene.add(new THREE.AmbientLight(0x222222));

  // Controls
  controls = new THREE.OrbitControls(camera, renderer.domElement);
  controls.enableRotate = false;
  controls.enableZoom = true;
  controls.enablePan = true;
  controls.screenSpacePanning = true;
  controls.maxPolarAngle = 0;
  controls.minPolarAngle = 0;
  controls.mouseButtons = { LEFT: THREE.MOUSE.PAN, MIDDLE: THREE.MOUSE.DOLLY, RIGHT: THREE.MOUSE.ROTATE };

  let gx = 3000/2;
  let gy = 0;
  let gz = -2250/2;
  let InitialZoom = 2000;
  controls.target.set(gx,gy,gz)
  camera.position.set(gx, InitialZoom,gz);
  camera.lookAt(gx,gy,gz);

  // Load initial terrain (frame 1)
  const {verticesArray, facesArray, colorsArray} = await loadTerrain(1);
  buildMesh(verticesArray, facesArray, colorsArray);

  // Slider setup
  const slider = document.getElementById('slider');
  slider.disabled = false;
  slider.value = 1;
  slider.oninput = async () => {
    const frameNum = parseInt(slider.value);
    const {verticesArray, facesArray, colorsArray} = await loadTerrain(frameNum);
    buildMesh(verticesArray, facesArray, colorsArray);
  };

  // Zoom buttons
  document.getElementById('zoomIn').onclick = () => zoomCamera(-zoomStep);
  document.getElementById('zoomOut').onclick = () => zoomCamera(zoomStep);

  window.addEventListener('resize', ()=>{
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });

  animate();
}

// ---------------- Zoom ----------------
function zoomCamera(step){
  camera.position.y = THREE.MathUtils.clamp(camera.position.y + step, minY, maxY);
}

// ---------------- Animate ----------------
function animate(){
  requestAnimationFrame(animate);
  controls.update();
  renderer.render(scene,camera);
}

window.addEventListener('load', init);
})();
</script>

</body>
</html>
