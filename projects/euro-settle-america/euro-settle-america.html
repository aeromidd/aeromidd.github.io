<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>High-Res Terrain Shader</title>
<style>
  body { margin:0; overflow:hidden; }
  #container { width:100vw; height:100vh; display:block; }
  #slider { position:absolute; top:10px; left:50%; transform:translateX(-50%); z-index:10; }
</style>
</head>
<body>

<input id="slider" type="range" min="1" max="6" step="1" value="1">
<div id="container"></div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.1.0/pako.min.js"></script>

<script>
(function(){
console.clear();
const SF = 0.3; //0.1<-->0.75
const nx = Math.ceil(3000*SF);  // downsampled mesh
const ny = Math.ceil(2250*SF);
const heightScale = nx/200;

let scene, camera, renderer, mesh, geometry;
let heightTex, colorTex;

const container = document.getElementById('container');
const slider = document.getElementById('slider');

window.addEventListener('load', init);

// ----------------- Init -----------------
function init(){
  scene = new THREE.Scene();

  // Camera
  camera = new THREE.PerspectiveCamera(50, window.innerWidth/window.innerHeight, 0.1, 5000);
  var cx = 0;
  var cy = 0;
  camera.position.set(cx, nx, cy);
  camera.lookAt(cx, heightScale, cy);

  // Renderer
  renderer = new THREE.WebGLRenderer({antialias:true});
  renderer.setClearColor(0xffffff); // white background
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.outputColorSpace = THREE.SRGBColorSpace;
  //renderer.toneMappingExposure = 1.5; // helps brightness
  container.appendChild(renderer.domElement);

  // Lights
  const directional = new THREE.DirectionalLight(0xffffff, 1.1);//1.5
  directional.position.set(-nx/2,nx,-ny);
  scene.add(directional);

  const ambient = new THREE.AmbientLight(0x222222);
  scene.add(ambient);

  buildMesh();

  slider.oninput = e => loadFrame(parseInt(e.target.value));
  loadFrame(1);

  window.addEventListener('resize', ()=>{
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });

  animate();
}

// ----------------- Build Mesh -----------------
function buildMesh(){

  geometry = new THREE.PlaneGeometry(nx, ny, nx-1, ny-1);
  geometry.rotateX(-Math.PI/2);   // now X/Z plane, Y is up
  geometry.computeVertexNormals();
  

  // ---- textures ----
  heightTex = new THREE.DataTexture(
    new Uint8Array(nx*ny),
    nx, ny,
    THREE.RedFormat
  );
  //heightTex.minFilter = heightTex.magFilter = THREE.LinearFilter;
heightTex.flipY = false;

  colorTex = new THREE.DataTexture(
    new Uint8Array(nx*ny*3),
    nx, ny,
    THREE.RGBFormat
  );
  colorTex.colorSpace = THREE.SRGBColorSpace;
  //colorTex.minFilter = colorTex.magFilter = THREE.LinearFilter;
  colorTex.flipY = false;
  

  // smoother sampling (important)
  heightTex.minFilter = heightTex.magFilter = THREE.LinearFilter;
  colorTex.minFilter  = colorTex.magFilter  = THREE.LinearFilter;

  heightTex.needsUpdate = true;
  colorTex.needsUpdate  = true;

  // ---- MATERIAL (no shaders) ----
  const material = new THREE.MeshStandardMaterial({
  map: colorTex,
  displacementMap: heightTex,
  displacementScale: heightScale,

  roughness: 0.9,
  metalness: 0.0,

  side: THREE.DoubleSide,
  flatShading: true
});


  mesh = new THREE.Mesh(geometry, material);
  // Center the mesh
mesh.position.x = 0;//-nx / 4;
mesh.position.z = 0///-ny / 4;
mesh.position.y = 0; // optional, usually 0 for displacement from plane
  scene.add(mesh);
}


// ----------------- Load Frame -----------------
async function loadFrame(t){
  try{
    const url = `https://raw.githubusercontent.com/aeromidd/aeromidd.github.io/main/projects/euro-settle-america/binFiles/frame_${String(t).padStart(4,'0')}.bin.gz`;
    const res = await fetch(url);
    if(!res.ok) throw new Error("Failed frame "+t);
    const compressed = await res.arrayBuffer();
    const decompressed = pako.inflate(new Uint8Array(compressed));//.buffer

    const hx = 3000;
    const hy = 2250;
    const fullCount = hx*hy;
    //const zFull = new Uint8Array(decompressed,0,fullCount);
    //const cFull = new Uint8Array(decompressed,fullCount,fullCount*3);
    const zFull = decompressed.subarray(0, fullCount);
    const cFull = decompressed.subarray(fullCount, fullCount*4);

    // Downsample to nx x ny
    const stepX = Math.floor(hx/nx);
    const stepY = Math.floor(hy/ny);

    const zSmall = new Uint8Array(nx*ny);
    const cSmall = new Uint8Array(nx*ny*3);
    //*
    for (let i = 0; i < ny; i++) {
  const v = i / (ny - 1);  // normalized 0->1
  const hiF = v * (hy - 1);
  const hi = Math.floor(hiF);

  for (let j = 0; j < nx; j++) {
    const u = j / (nx - 1);
    const hjF = u * (hx - 1);
    const hj = Math.floor(hjF);

    const idxSmall = i * nx + j;
    const idxFull = hi * hx + hj;

    zSmall[idxSmall] = zFull[idxFull];
    const idxSmallC = idxSmall*3;
    cSmall[idxSmallC]   = cFull[idxFull*3];
    cSmall[idxSmallC+1] = cFull[idxFull*3+1];
    cSmall[idxSmallC+2] = cFull[idxFull*3+2];
  }
}
    //*/

    heightTex.image.data = zSmall;
    heightTex.needsUpdate = true;

    colorTex.image.data = cSmall;
    colorTex.needsUpdate = true;
    mesh.material.needsUpdate = true;

  }catch(err){console.error(err);}
}

// ----------------- Animate -----------------
function animate(){
  requestAnimationFrame(animate);
  renderer.render(scene,camera);
}

})();
</script>

</body>
</html>

